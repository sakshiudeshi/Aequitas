let valueParser = require('postcss-value-parser')

function parseValue (value) {
  let parsed = value.match(/([\d.-]+)(.*)/)
  if (!parsed || !parsed[1] || !parsed[2] || isNaN(parsed[1])) {
    return undefined
  }
  return [parseFloat(parsed[1]), parsed[2]]
}

function compose (first, second, third) {
  if (first && second && third) {
<<<<<<< HEAD
    return `max(${ first }, min(${ second }, ${ third }))`
  }
  if (first && second) {
    return `max(${ first }, ${ second })`
=======
    return `max(${first}, min(${second}, ${third}))`
  }
  if (first && second) {
    return `max(${first}, ${second})`
>>>>>>> e2d7f962f817b61d64a1d00ca7a3cbb114a99fe6
  }

  return first
}

function updateValue (declaration, value, preserve) {
<<<<<<< HEAD
  if (preserve) {
    declaration.cloneBefore({ value })
  } else {
    declaration.value = value
=======
  let newValue = value
  let newValueAst = valueParser(value)
  let valueAST = valueParser(declaration.value)

  // Means clamp is not alone within the declaration
  if (valueAST.nodes.length > 1) {
    let clampIndex = valueAST.nodes.findIndex(
      node => node.type === 'function' && node.value === 'clamp'
    )

    valueAST.nodes = [
      ...valueAST.nodes.slice(0, clampIndex),
      ...newValueAst.nodes,
      ...valueAST.nodes.slice(clampIndex + 1)
    ]

    newValue = valueAST.toString()
  }

  if (preserve) {
    declaration.cloneBefore({ value: newValue })
  } else {
    declaration.value = newValue
>>>>>>> e2d7f962f817b61d64a1d00ca7a3cbb114a99fe6
  }
}

module.exports = opts => {
  opts = opts || {}
  let precalculate = opts.precalculate ? Boolean(opts.precalculate) : false
  let preserve = opts.preserve ? Boolean(opts.preserve) : false

  return {
    postcssPlugin: 'postcss-clamp',
    Declaration (decl) {
      if (!decl || !decl.value.includes('clamp')) {
        return
      }
      valueParser(decl.value).walk(node => {
        let nodes = node.nodes
        if (
          node.type !== 'function' ||
<<<<<<< HEAD
            node.value !== 'clamp' ||
            nodes.length !== 5
=======
          node.value !== 'clamp' ||
          nodes.length !== 5
>>>>>>> e2d7f962f817b61d64a1d00ca7a3cbb114a99fe6
        ) {
          return
        }
        let first = nodes[0]
        let second = nodes[2]
        let third = nodes[4]
        let naive = compose(
          valueParser.stringify(first),
          valueParser.stringify(second),
          valueParser.stringify(third)
        )
<<<<<<< HEAD
        if (
          !precalculate ||
          second.type !== 'word' ||
          third.type !== 'word'
        ) {
          updateValue(
            decl,
            naive,
            preserve
          )
=======
        if (!precalculate || second.type !== 'word' || third.type !== 'word') {
          updateValue(decl, naive, preserve)
>>>>>>> e2d7f962f817b61d64a1d00ca7a3cbb114a99fe6
          return
        }
        let parsedSecond = parseValue(second.value)
        let parsedThird = parseValue(third.value)
        if (parsedSecond === undefined || parsedThird === undefined) {
<<<<<<< HEAD
          updateValue(
            decl,
            naive,
            preserve
          )
=======
          updateValue(decl, naive, preserve)
>>>>>>> e2d7f962f817b61d64a1d00ca7a3cbb114a99fe6
          return
        }
        let [secondValue, secondUnit] = parsedSecond
        let [thirdValue, thirdUnit] = parsedThird
        if (secondUnit !== thirdUnit) {
<<<<<<< HEAD
          updateValue(
            decl,
            naive,
            preserve
          )
=======
          updateValue(decl, naive, preserve)
>>>>>>> e2d7f962f817b61d64a1d00ca7a3cbb114a99fe6
          return
        }
        let parsedFirst = parseValue(first.value)
        if (parsedFirst === undefined) {
<<<<<<< HEAD
          let secondThirdValue =
            `${ secondValue + thirdValue }${ secondUnit }`
=======
          let secondThirdValue = `${secondValue + thirdValue}${secondUnit}`
>>>>>>> e2d7f962f817b61d64a1d00ca7a3cbb114a99fe6
          updateValue(
            decl,
            compose(valueParser.stringify(first), secondThirdValue),
            preserve
          )
          return
        }
        let [firstValue, firstUnit] = parsedFirst
        if (firstUnit !== secondUnit) {
<<<<<<< HEAD
          let secondThirdValue =
            `${ secondValue + thirdValue }${ secondUnit }`
=======
          let secondThirdValue = `${secondValue + thirdValue}${secondUnit}`
>>>>>>> e2d7f962f817b61d64a1d00ca7a3cbb114a99fe6
          updateValue(
            decl,
            compose(valueParser.stringify(first), secondThirdValue),
            preserve
          )
          return
        }

        updateValue(
          decl,
<<<<<<< HEAD
          compose(`${ firstValue + secondValue + thirdValue }${ secondUnit }`),
=======
          compose(`${firstValue + secondValue + thirdValue}${secondUnit}`),
>>>>>>> e2d7f962f817b61d64a1d00ca7a3cbb114a99fe6
          preserve
        )
      })
    }
  }
}

module.exports.postcss = true
